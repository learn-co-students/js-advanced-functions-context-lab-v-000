/* Your Code Here */

/*
 We're giving you this function. Take a look at it, you might see some usage
 that's new and different. That's because we're avoiding a well-known, but
 sneaky bug that we'll cover in the next few lessons!

 As a result, the lessons for this function will pass *and* it will be available
 for you to use if you need it!
 */

let allWagesFor = function () {
    let eligibleDates = this.timeInEvents.map(function (e) {
        return e.date
    })

    let payable = eligibleDates.reduce(function (memo, d) {
        return memo + wagesEarnedOnDate.call(this, d)
    }.bind(this), 0) // <== Hm, why did we need to add bind() there? We'll discuss soon!

    return payable
}

/*

function createEmployeeRecord(employeeArray) {
    console.log(this)
    let thisEmployeeArray = employeeArray
    var testEmployee = {
        firstName: this[0],
        familyName: this[1],
        title: this[2],
        payPerHour: this[3],
        timeInEvents: [],
        timeOutEvents: []
    }
}

*/

function createEmployeeRecord(employeeArray) {
    //console.log(employeeArray);
    //console.log(employeeRecords);
    var testEmployee = {
      firstName: employeeArray[0],
      familyName: employeeArray[1],
      title: employeeArray[2],
      payPerHour: employeeArray[3],
      timeInEvents: [],
      timeOutEvents: [],
    };
    return testEmployee;
  }
  
  function createEmployeeRecords(arrayOfArrays) {
    //process an Array of Arrays into an Array of employee records
    //console.log(arrayOfArrays)
    var arrayOfRecords = [];
    arrayOfArrays.forEach((employeeArray) => {
      //console.log(employeeArray);
      var newRecord = createEmployeeRecord(employeeArray);
      arrayOfRecords.push(newRecord);
    });
    return arrayOfRecords;
  }

  function createTimeInEvent(dateStamp) {// this and call should be used on this according to the test, but also because employeerecord is constantly given
    //console.log(dateStamp);
    //console.log(this); //this replaces employeeRecord
    //employeeRecord.type = "TimeIn";
  
    var timeNDate = dateStamp.split(" ");
    //employeeRecord.date = timeNDate[0];
    //employeeRecord.time = timeNDate[1];
    //console.log(employeeRecord)
    //console.log(timeNDate[1])
    //it adds a timeIn event Object to an employee's record of timeInEvents when provided an employee record and Date/Time String and returns the updated record
    var hourInt = parseInt(timeNDate[1]);
    var timeIn = { 
      type: "TimeIn",
      date: timeNDate[0],
      hour: hourInt //test expected an int
    };
    this.timeInEvents.push(timeIn);
    return this;
  }
  
  function createTimeOutEvent(dateStamp) {
    //console.log(employeeRecord);
    //console.log(dateStamp);
    //employeeRecord.type = "TimeOut";
  
    var timeNDate = dateStamp.split(" ");
    //employeeRecord.date = timeNDate[0];
    //employeeRecord.time = timeNDate[1];
    //console.log(timeNDate[1])
    var hourInt = parseInt(timeNDate[1]);
    var timeOut = { 
      type: "TimeOut",
      date: timeNDate[0],
      hour: hourInt 
    };
    this.timeOutEvents.push(timeOut);
    return this;
  }
  
  function hoursWorkedOnDate(date){
      //console.log(employeeRecord)
      //console.log(date)
      //console.log(employeeRecord.timeInEvents[0]["hour"])
      //console.log(employeeRecord.timeOutEvents[0]["hour"])
      var matchingTimeInDate = this.timeInEvents.find(element => element.date === date)
      var matchingTimeOutDate = this.timeOutEvents.find(element => element.date === date)
  
      var hourStarted = matchingTimeInDate.hour
      //console.log(hourStarted)
      var hourEnded = matchingTimeOutDate.hour
      //console.log(hourEnded)
      var hoursTotal = ((hourEnded - hourStarted)/100)
      return hoursTotal
  }

  function wagesEarnedOnDate(date) {
    console.log(hoursWorkedOnDate.call(this,date))// call is implemented when this is involved and another function is
    var hours = hoursWorkedOnDate.call(this,date)
    //console.log(employeeRecord)
    var pay = this.payPerHour
    var paycheck = pay * hours
    return paycheck
}

function calculatePayroll(employeeRecordArray){
  //console.log(employeeRecordArray)
  var Payroll = []
  employeeRecordArray.forEach(employeeRecord => {
      var employeeFullWages = allWagesFor.call(employeeRecord) //allWagesFor must be called otherwise its undefined. Maybe due to it's structuring
      Payroll.push(employeeFullWages)
  })
  //console.log(Payroll)
  var totalPay = Payroll.reduce((total,element) => total + element)
  return totalPay
}

function findEmployeeByFirstName(srcArray,firstName) {

  return srcArray.find(employeeRecord => employeeRecord.firstName === firstName)

  //https://medium.com/front-end-weekly/3-things-you-didnt-know-about-the-foreach-loop-in-js-ff02cec465b1 
  //There's nothing generated by the forEach that we want to preserve (if that were so, we'd want to use map). The employee, e, is updated as a side-effect of running forEach. The only clue that helps us guess what forEach is for here is that the programmer "wrapped" it inside of a helpfully-named function name.
  //for each is trash for the most part^

  //srcArray.forEach(employeeRecord => {
    //  if (employeeRecord.firstName === firstName){
      //    console.log(employeeRecord)
        //  return employeeRecord
      //}
  //})
}